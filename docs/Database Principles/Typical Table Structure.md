## Typical Table Structure
Our typical table structure would look something like:

```
create table employee
(
    id integer generated by default as identity primary key,

	... other columns ...

	employee_type varchar(64) default 'Janitor' not null,
	company_id integer default null
		references sysuser deferrable initially deferred,

	... other columns ...

    is_active boolean default true not null,
    inserted_sysuser_id integer default 0 not null
        references sysuser deferrable initially deferred,
    inserted_ts timestamp with time zone default now() not null,
    updated_sysuser_id integer default 0 not null
        references public.sysuser deferrable initially deferred,
    updated_ts timestamp with time zone default now() not null

	... future columns ...
);

comment on table employee is 'Employee of a company';

comment on column employee.employee_type is 'Type of employee {enum: EEmployeeType.Janitor}';
```

NOTE: Each downstream system may have a different naming convention for inserted_* and updated_*, so please check with your local repository for how it should handle these.

Let's break down the critical elements of what a typical table structure would look like.

### Table name is singular
It would be tempting to name your table something like `employees`.  Don't do it!  I know that the table holds multiple employee records.  However, for consistency, we want to do things like have foreign key references use the format `{table_name}_id`.  Thus something like employees_id would not really make sense.

Because our system generates interfaces and classes for each table, the generated interface would be called `Iemployees` for a single object.  We want the interface to be `Iemployee`, so we need the table to be called `employee`

As a result, when you're dealing with an array of values and the main object was plural, what would you call the array?  `employeess`?  No.  You want the array to be called `employees` and each element to be called an `employee`.

### ID Primary Key
Pretty simple, for the unique `id` of the table use an integer with `generated by default as identity`.

### Other Columns
Other columns generally go between the `id` and `is_active` section.

### Sample column: employee_type as an enum
We provided this example because we want to show how an Enum is stored in the database.  Note, that we do not use the Enums in PostgreSQL.  We tried that.  But changing the structure of that data type is a nightmare, so avoid it.

Instead, we want to provide the enum safety on the TypeScript side.  So, you'll notice at the bottom there is a comment on this column with no only a description (which will show up as documentation in the TypeScript interface generated), but also a reference to a TypeScript enum type with a default value, as in `{enum: EEmployeeType.Janitor}`.  This tells the TypeScript file generator to reference the enum, providing type safety in the browser and server.

## Sample column: company_id as a foreign key
We already covered this when we talked about the need for the table name to be singular.  But, here is the other side of the reason for that requirements which is that foreign keys that reference another table once in the current table should use the format:

```
{table_name}_id
```
This is to provide readability across the app.  PLEASE do not use different or abbreviated names as column names.  If the foreign table is company, we don't want to see things like co_id, comp_id, business_id, etc.  It needs to match the name of the table exactly, so `company_id` other wise people coming behind you will be confused.  I guarantee it!

In the instance where a single table is going to reference the same foreign table more than once, then we'll want to prepend this format with some descriptor.  Thus:
```
{descriptor}_{table_name}_id
```
This example is obvious in the columns near the end of the table, such as `inserted_sysuser_id` and `updated_sysuser_id`.

### Typical column: is_active
We RARELY delete anything out of the database.  Instead, we mark it inactive.

To have a consistent way to mark things inactive across all tables, use `is_active`.

Most tables will need this field.  Almost never should you exclude it.

### Typical columns: inserted/updated - sysuser_id/ts
These 4 columns should almost always be on every single table.

The exceptions for the sysuser_id columns where a table has inserts from a cron_job (thus don't have an active user in the system).

The exception for the updated_ts is for a table that is strictly transactional, and doesn't handle updates.

Otherwise, the `inserted_sysuser_id` and `updated_sysuser_id` columns track who inserted the record and who last updated it.

The `inserted_ts` and `updated_ts` columns track when the record was inserted and when it was last updated.

NOTE: this is the one area that we have some deviance across applications due to legacy data conversions.  In some cases you'll see `added_sysuser_id` and `modified_sysuser_id`.  But, we'd prefer to stick with the database nomenclature of `inserted` and `updated`.

Also, some databases have `inserted_date` or `updated_date`.  But this can get confusing because what is really being stored is a date/time value, not just date.  So, we'd prefer the `inserted_ts` nomenclature.

### Future columns
PostgreSQL does not allow for re-ordering columns (at least, not without dropping and re-creating the whole table).

It has been helpful in the past to see which columns were present when the table was initially generated (... other columns ...), and which came later (... future columns ...).  So, we'll take advantage of any database shortcomings we can.
